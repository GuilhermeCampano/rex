Rex('h.cElement', [
  
  'cond',
  'get',
  'reduce',
  'h.isNode',
  'h.isText',
  'h.nUpdate'
  
], function (cond, get, reduce, isNode, isText, nUpdate) {
  
  function createChild(node, vDOM) {
    return node.appendChild(solve(vDOM)), node;
  }
  
  function createText(vDOM) {
    return document.createTextNode(get(vDOM, 'textContent'));
  }
  
  function createElement(vDOM) {
    return reduce(get(vDOM, 'childNodes'), createChild, nUpdate(document.createElement(get(vDOM, 'tagName')), vDOM));
  }

  function solve(vDOM) {
    return cond([
      [isNode, createElement],
      [isText, createText]
    ])(vDOM);
  }
  
  return solve;
  
});
Rex('h', [
  
  'h.parseChild',
  'h.parseProperty',
  'h.parseTag',
  'h.vNode'

], function (parseChild, parseProperty, parseTag, vNode) {
  
  function solve(tagName, property, children) {
    return vNode(parseTag(tagName, property), property, children);
  }
  
  return function (tagName, property, children) {
    return solve(tagName, parseProperty(property), parseChild(children, property));
  };
  
});
Rex('h.isHook', [
  
  'equal',
  'get'

], function (equal, get) {
  
  return function (type, vDOM) {
    return equal(type, get(vDOM, 'nodeType'));
  };
  
});
Rex('h.isNode', ['partial', 'h.isHook'], function (partial, isHook) {
  return partial(isHook, [1]);
});
Rex('h.isText', ['partial', 'h.isHook'], function (partial, isHook) {
  return partial(isHook, [3]);
});
Rex('h.nExchange', ['h.cElement'], function (cElement) {
  
  return function (son, vDOM, dad) {
    return dad.replaceChild(cElement(vDOM), son);
  };
  
});
Rex('h.nExtend', [

  'curry',
  'get',
  'keys',
  'reduce',
  'set',
  '_'

], function (curry, get, keys, reduce, set, _) {
  
  function extend(node, properties, key) {
    return set(node, key, get(properties, key, ''));
  }

  return function (node, properties) {
    return reduce(keys(properties), curry(extend)(_, properties, _), node);
  };
  
});
Rex('h.nInsert', [

  'equal',
  'get',
  'h.cElement'

], function (equal, get, cElement) {
  
  return function (_, vDOM, dad) {
    return equal(get(dad, 'nodeType', 0), 1) && dad.appendChild(cElement(vDOM));
  };
  
});
Rex('h.nRemove', [], function () {
  
  return function (son, _, dad) {
    return dad.removeChild(son), { childNodes: [] };
  };
  
});
Rex('h.nUpdate', [

  'cond',
  'forEach',
  'get',
  'or',
  'partial',
  'set',
  'h.isNode',
  'h.isText',
  'h.nExtend'

], function (cond, forEach, get, or, partial, set, isNode, isText, nExtend) {
  
  function merge(node, properties, key) {
    return nExtend(get(node, key), or(get(properties, key), {}));
  }
  
  function update(node, properties) {
    return forEach(['dataset', 'style'], partial(merge, [node, properties])), (delete properties['style']), nExtend(node, properties);
  }
  
  function updateNode(node, vDOM) {
    return update(node, get(vDOM, 'properties'));
  }
  
  function updateText(node, vDOM) {
    return set(node, 'textContent', get(vDOM, 'textContent')), node;
  }
  
  return cond([
    [isNode, updateNode],
    [isText, updateText]
  ]);
  
});
Rex('h.parseChild', [

  'arity',
  'cond',
  'curry',
  'flip',
  'isArray',
  'isNumber',
  'isString',
  'or',
  'push',
  'reduce',
  't',
  'h.isNode',
  'h.isText',
  'h.vText',
  '_'

], function (arity, cond, curry, flip, isArray, isNumber, isString, or, push, reduce, t, isNode, isText, vText, _) {
  
  function addArray(vDOM, children) {
    return reduce(vDOM, curry(arity(2, flip(solve))), children);
  }
  
  function addNumber(vDOM, children) {
    return addString(String(vDOM), children);
  }
  
  function addString(vDOM, children) {
    return push(children, vText(vDOM)), children;
  }
  
  function addvDOM(vDOM, children) {
    return push(children, vDOM), children;
  }
  
  function gap(_, children) {
    return children;
  }

  function solve(vDOM, children) {
    return cond([
      [isString, addString],
      [isNumber, addNumber],
      [isArray, addArray],
      [isText, addvDOM],
      [isNode, addvDOM],
      [t, gap]
    ])(vDOM, children);
  }
  
  return function (children, properties) {
    return solve(or(or(children, properties), {}), []);
  };
  
});
Rex('h.parseProperty', ['isObject'], function (isObject) {
  
  return function (a) {
    return isObject(a) ? a : {};
  };
  
});
Rex('h.parseTag', [
  
  'both',
  'charAt',
  'compose',
  'concat',
  'curry',
  'equal',
  'get',
  'join',
  'or',
  'partial',
  'reduce',
  'set',
  'split',
  'substring',
  'test',
  'toUpperCase',
  'trim',
  '_'

], function (both, charAt, compose, concat, curry, equal, get, join, or, partial, reduce, set, split, substring, test, toUpperCase, trim, _) {
  
  function compare(value, char) {
    return equal(charAt(value, 0), char);
  }
  
  function id(property, h) {
    return both(curry(compare)(_, '#'), compose(partial(set, [property, 'id']), sub))(h), h;
  }
  
  function klass(property, h) {
    return both(curry(compare)(_, '.'), compose(partial(set, [property, 'className']), partial(names, [property])))(h), h;
  }
  
  function names(property, h) {
    return trim(join(concat(split(get(property, 'className', ''), ' '), [sub(h)]), ' '));
  }
  
  function solve(property, tagName, h) {
    return compose(partial(klass, [property]), partial(id, [property]))(h), testTag(tagName, h);
  }
  
  function sub(h) {
    return substring(h, 1, get(h, 'length'));
  }
  
  function testTag(tagName, h) {
    return test(/^\.|#/, h) ? tagName : or(h, tagName);
  }
  
  return function (tagName, property) {
    return toUpperCase(reduce(split(tagName, /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/), partial(solve, [or(property, {})]), 'DIV'));
  };
  
});
Rex('h.reflow', [

  'forEach',
  'get',
  'max',
  'sparse',
  'h.repaint'

], function (forEach, get, max, sparse, repaint) {

  function getChildren(node) {
    return get(get(node, 'childNodes', []), 'length', 0);
  }
  
  function reflowChild(node, vDOM, iNode, iVDOM) {
    return reflowNode(get(node, 'childNodes', [])[iNode], get(vDOM, 'childNodes', [])[iVDOM], node), node;
  }
  
  function reflowNode(node, vDOM, parentNode) {
    return solve(repaint(node, vDOM, get(node, 'parentNode', parentNode)), vDOM);
  }
  
  function solve(node, vDOM) {
    return forEach(sparseOfChildren(node, vDOM), function (_, indice, children) {
      reflowChild(node, vDOM, (indice - (children.length - sparseOfChildren(node, vDOM).length)), indice);
    }), node;
  }
  
  function sparseOfChildren(node, vDOM) {
    return sparse(max(getChildren(node), getChildren(vDOM)));
  }
  
  return reflowNode;
  
});
Rex('h.repaint', [
  
  'and',
  'cond',
  'different',
  'equal',
  'get',
  'f',
  't',
  'h.nExchange',
  'h.nInsert',
  'h.nRemove',
  'h.nUpdate'
  
], function (and, cond, different, equal, get, f, t, nExchange, nInsert, nRemove, nUpdate) {
  
  function gap(node, vDOM) {
    return and(equal(!!node, false), equal(!!vDOM, false));
  }
  
  function remove(node, vDOM) {
    return and(equal(!!node, true), equal(!!vDOM, false));
  }
  
  function exchange(node, vDOM) {
    return different(get(node, 'tagName'), get(vDOM, 'tagName'));
  }
  
  function insert(node, vDOM) {
    return and(equal(!!node, false), equal(!!vDOM, true));
  }
  
  return cond([
    [gap, f],
    [remove, nRemove],
    [insert, nInsert],
    [exchange, nExchange],
    [t, nUpdate]
  ]);
  
});
Rex('h.vNode', [], function () {
  
  return function vNode(tagName, properties, children) {
    
    return !(this instanceof vNode)

    ? new vNode(tagName, properties, children)
    
    : {
      
      get childNodes() {
        return children;
      },
      
      get nodeType() {
        return 1;
      },
      
      get properties() {
        return properties;
      },
      
      get tagName() {
        return tagName;
      }
      
    };
    
  };
  
});
Rex('h.vText', [], function () {
  
  return function vText(text) {
    
    return !(this instanceof vText)

    ? new vText(text)
    
    : {
      
      get nodeType() {
        return 3;
      },
      
      get textContent() {
        return text;
      }
      
    };
    
  };
  
});